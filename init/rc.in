#! /bin/bash
#
# rc            This file is responsible for starting/stopping
#               services when the runlevel changes.
#
# * 04 March 2003, Jaco Greeff <jaco@puxedo.org>
# - Modified from the Mandrake rc script; removed
#   disable_splash part to keep an alive FB bootsplash
#
# Original Author:
#               Miquel van Smoorenburg, <miquels@drinkel.nl.mugnet.org>
#

# check a file to be a correct runlevel script
check_runlevel ()
{
	# Check if the file exists at all.
	[ -x "$1" ] || return 1

	# Reject backup files and files generated by rpm.
	case "$1" in
		*.rpmsave|*.rpmorig|*.rpmnew|*~|*.orig)
			return 1
			;;
	esac
        a=$[service++]
	return 0
}

# Now find out what the current and what the previous runlevel are.
argv1="$1"
set `/sbin/runlevel`
runlevel=$2
previous=$1
export runlevel previous

# Get first argument. Set new runlevel to this argument.
if [ "$argv1" != "" ] ; then
 newrunlevel="$argv1"
else
 newrunlevel="$runlevel"
fi

if [ "$previous" = "N" ];then
    if [ -e /var/run/failsafe ];then
        rm -f /var/run/failsafe
	if [ -x /sbin/askrunlevel ];then
		/sbin/askrunlevel --interactive && ASKRUNLEVEL=no
	else
	    init 1 #jump to init 1 if not aksrunlevel.
       fi
    fi
fi

. /etc/init.d/functions

#initsplash
initquiet

# See if we want to be in user confirmation mode
if [ "$previous" = "N" ]; then
	if [ -f /var/run/confirm ] \
			|| grep -i confirm /proc/cmdline >/dev/null ; then
		rm -f /var/run/confirm
		CONFIRM=yes
		export CONFIRM
		gprintf "Entering interactive startup\n"
	else
	        /bin/grep -q quiet /proc/cmdline && /bin/grep -vq noquiet /proc/cmdline && export quiet=yes
		[[ "$splash" = "yes" && -n "$pw" && -f /proc/splash ]] && grep -q "Splash.*on" /proc/splash && export progress=yes
		gprintf "Entering non-interactive startup\n"
	fi
elif [[ "$newrunlevel" = "0" || "$newrunlevel" = "6" ]]; then
    chvt 1
    [[ -n $out ]] && exec &>"$out"1
    # Make sure terminal is using correct character set.
    # When booting this implicitly happens in rc.sysinit, but when shutting
    # down terminal can be left in wrong state
    [[ -f /etc/init.d/mandrake_consmap ]] && . /etc/init.d/mandrake_consmap
    if [[ "$splash" = "yes" && -n "$pw" && -f /proc/splash ]]; then
	export progress=yes
	echo 1 > /proc/splash
    fi
    if /bin/grep -q quiet /proc/cmdline && /bin/grep -vq noquiet /proc/cmdline; then
	export quiet=yes
	[[ -x /usr/bin/clear ]] && /usr/bin/clear
	echo
	[[ "$newrunlevel" = "0" ]] && gprintf "Shutting down, please wait..."
	[[ "$newrunlevel" = "6" ]] && gprintf "Rebooting, please wait..."
	echo
    fi
fi

initquiet
quiet on

# Tell linuxconf what runlevel we are in
[ -d /var/run ] && echo "/etc/rc$runlevel.d" > /var/run/runlevel.dir

# Get first argument. Set new runlevel to this argument.
[ -n "$argv1" ] && runlevel="$argv1"

# Is there an rc directory for this new runlevel?
[ -d /etc/rc$runlevel.d ] || exit 0

# First, run the KILL scripts.
for i in /etc/rc$runlevel.d/K* ; do
	check_runlevel "$i" || continue

	progress $service
	# Check if the subsystem is already up.
	subsys=${i#/etc/rc$runlevel.d/K??}
	[ -f /var/lock/subsys/$subsys -o -f /var/lock/subsys/$subsys.init ] \
		|| continue

	# Bring the subsystem down.
	if egrep -q "(killproc |action )" $i ; then
		$i stop
	else
		action "Stopping %s: " $subsys $i stop
	fi
done

# Now run the START scripts.
for i in /etc/rc$runlevel.d/S* ; do
	check_runlevel "$i" || continue

	# Check if the subsystem is already up.
	subsys=${i#/etc/rc$runlevel.d/S??}
	[ -f /var/lock/subsys/$subsys -o -f /var/lock/subsys/$subsys.init ] \
		&& continue

	# If we're in confirmation mode, get user confirmation
	if [ -n "$CONFIRM" ]; then
		confirm $subsys
		case $? in
			0) :;;
			2) CONFIRM=;;
			*) continue;;
		esac
	fi

	if [[ "$subsys" = "harddrake" && "$quiet" = "yes" ]]; then
	    quiet off
	    export quiet=stop
	fi

	progress $service

	# Bring the subsystem up.
	if [ "$subsys" = "halt" -o "$subsys" = "reboot" ]; then
		export LC_ALL=C
		exec $i start
	fi
#	if [ "$subsys" = "halt" -o "$subsys" = "reboot" -o "$subsys" = "single" ]; then
#	    disable_splash
#        fi
	if egrep -q "(daemon |action )" $i 2>/dev/null \
			|| [ "$subsys" = "single" -o "$subsys" = "local" ]; then
		$i start
	else
		action "Starting %s: " $subsys $i start
	fi

	if [[ "$quiet" = "stop" ]]; then
	    export quiet=yes
	    quiet on
	fi
done

#disable_splash
